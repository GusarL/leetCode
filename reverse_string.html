<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Two sum</title>
</head>
<body>
<script>
	// Given a 32-bit signed integer, reverse digits of an integer.
	const reverse = function(x) {
		let result;
		const numberToString = String(x);
		let revertedString = numberToString.split('').reverse().join('');
		result = +revertedString;
		if (/-$/.test(revertedString)) {
			result = revertedString.replace(/-$/, "");
			result = -Number(result);
		}
		if(/0$/.test(revertedString)) {
			result = +revertedString.replace(/.$/, "");
		}
		if (result < -(2**31) || result > (2**31 - 1)) {
			result = 0;
		}
		return result;
	};
//correct variant
// 	Approach 1: Pop and Push Digits & Check before Overflow
// 	Intuition
//
// 	We can build up the reverse integer one digit at a time. While doing so, we can check beforehand whether or not appending another digit would cause overflow.
//
// 		Algorithm
//
// 	Reversing an integer can be done similarly to reversing a string.
//
// 		We want to repeatedly "pop" the last digit off of xx and "push" it to the back of the \text{rev}rev. In the end, \text{rev}rev will be the reverse of the xx.
//
// 		To "pop" and "push" digits without the help of some auxiliary stack/array, we can use math.

//pop operation:
// 		pop = x % 10;
// 	x /= 10;
//
// 	//push operation:
// 	temp = rev * 10 + pop;
// 	rev = temp;
// 	However, this approach is dangerous, because the statement \text{temp} = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop can cause overflow.
//
// 		Luckily, it is easy to check beforehand whether or this statement would cause an overflow.
//
// 		To explain, lets assume that \text{rev}rev is positive.
//
// 		If temp = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop causes overflow, then it must be that \text{rev} \geq \frac{INTMAX}{10}rev≥
// 10
// 	INTMAX
// ​
//
// If \text{rev} > \frac{INTMAX}{10}rev>
// 	10
// 	INTMAX
// ​
// 	, then temp = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop is guaranteed to overflow.
// 		If \text{rev} == \frac{INTMAX}{10}rev==
// 	10
// 	INTMAX
// ​
// 	, then temp = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop will overflow if and only if \text{pop} > 7pop>7
// 	Similar logic can be applied when \text{rev}rev is negative.
// 	class Solution {
// 		public int reverse(int x) {
// 		int rev = 0;
// 		while (x != 0) {
// 		int pop = x % 10;
// 		x /= 10;
// 		if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
// 		if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
// 		rev = rev * 10 + pop;
// 	}
// 	return rev;
// 	}
// 	}

</script>
</body>
</html>

