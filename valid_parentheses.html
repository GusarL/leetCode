<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Two sum</title>
</head>
<body>
<script>
	// const isValid = function (s) {
	// 	const sArray = s.split('');
	// 	const bracketMap = {
	// 		'(': ')',
	// 		'[': ']',
	// 		'{': '}'
	// 	}
	// 	let resultStack = [];
	// 	let stopFlag = false;
	// 	sArray.forEach(letter => {
	// 		if (letter === "(" || letter === "[" || letter === "{") {
	// 			resultStack.push(letter);
	// 			return;
	// 		}
	// 		if (letter === ")" || letter === "]" || letter === "}") {
	// 			if (!resultStack.length) {
	// 				return stopFlag = true
	// 			}
	// 			if (bracketMap[resultStack[resultStack.length - 1]] === letter) {
	// 				resultStack.pop();
	// 			} else {
	// 				stopFlag = true;
	// 			}
	// 		}
	// 	});
	//
	// 	return stopFlag ? false : resultStack.length === 0;
	// };
	// console.log(isValid("(])"));
//correct variant
	
	// class Solution {
	//
	// 	// Hash table that takes care of the mappings.
	// 	private HashMap<Character, Character> mappings;
	//
	// 	// Initialize hash map with mappings. This simply makes the code easier to read.
	// 	public Solution() {
	// 		this.mappings = new HashMap<Character, Character>();
	// 		this.mappings.put(')', '(');
	// 		this.mappings.put('}', '{');
	// 		this.mappings.put(']', '[');
	// 	}
	//
	// 	public boolean isValid(String s) {
	//
	// 	// Initialize a stack to be used in the algorithm.
	// 	Stack<Character> stack = new Stack<Character>();
	//
	// 	for (int i = 0; i < s.length(); i++) {
	// 	char c = s.charAt(i);
	//
	// 	// If the current character is a closing bracket.
	// 	if (this.mappings.containsKey(c)) {
	//
	// 	// Get the top element of the stack. If the stack is empty, set a dummy value of '#'
	// 	char topElement = stack.empty() ? '#' : stack.pop();
	//
	// 	// If the mapping for this bracket doesn't match the stack's top element, return false.
	// 	if (topElement != this.mappings.get(c)) {
	// 	return false;
	// }
	// } else {
	// 	// If it was an opening bracket, push to the stack.
	// 	stack.push(c);
	// }
	// }
	//
	// // If the stack still contains elements, then it is an invalid expression.
	// return stack.isEmpty();
	// }
	// }
	
	//correct option in JavaScript
	class Stack {
		constructor () {
			this.storage = {};
			this.count = 0;
	  }
	  
	  getCount () {
			return this.count;
		}
		
		push(val){
			this.storage[this.count] = val;
			this.count++;
		}
		
		pop(){
			if(this.count === 0){
				return undefined;
			}
			this.count--;
			let result = this.storage[this.count];
			delete this.storage[this.count];
			
			return result;
		}
		
		peek(){
			return this.storage[this.count - 1];
		}
		
		isEmpty(){
			return this.count === 0;
		}
	}
	const isValid = function (s) {
		let stack = new Stack();
		for (let character of s){
			if (character === '{' || character === '[' || character === '(') {
			stack.push(character);
			} else if (!stack.isEmpty() && character === '}' && stack.peek() === '{') {
				stack.pop();
			} else if (!stack.isEmpty() && character === ']' && stack.peek() === '[') {
				stack.pop();
			} else if (!stack.isEmpty() && character === ')' && stack.peek() === '(') {
				stack.pop();
				} else {
				return false;
			}
		}
		return stack.isEmpty();
	}
	console.log(isValid("(])"));

</script>
</body>
</html>

